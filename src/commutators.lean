import algebra.group_power

noncomputable theory
local attribute [instance] classical.prop_decidable


variables {α : Type} [group α] {a b g h : α}

def comm (a b : α) := a*b*a⁻¹*b⁻¹
local notation `[[`a, b`]]` := comm a b

lemma commuting : [[a, b]] = 1 ↔ a*b = b*a :=
by simp [comm, mul_inv_eq_iff_eq_mul]

local attribute [simp] mul_assoc


def conj (a b : α) := a*b*a⁻¹

lemma inv_conj : (conj b a)⁻¹ = conj b (a⁻¹) := by simp[conj]

lemma conj_mph : conj g (a * b) = (conj g a) * (conj g b) :=
by simp[conj]

lemma conj_action : conj (g * h) a = conj g (conj h a) :=
by simp[conj]

lemma commutator_trading : [[g⁻¹*a*g, b]] = 1 → 
∃ c d e f : α, [[a, b]] = (conj c g)*(conj d g⁻¹)*(conj e g)*(conj f g⁻¹) :=
begin
  intro comm_hyp,

  let a':= g⁻¹*a*g,
  have H : g*a'*g⁻¹ = a, by simp [a'],

  have := calc 
  [[a, b]] = a * b * a⁻¹ * b⁻¹ : rfl
      ...  = g * a' * g⁻¹ * (a'⁻¹ * a') * b * g * a'⁻¹ * (b⁻¹ * b) * g⁻¹ * b⁻¹ : by simp [H]
      ...  = g * a' * g⁻¹ * a'⁻¹ * b * a' * g * a'⁻¹ * b⁻¹ * b * g⁻¹ * b⁻¹ : by simp [commuting.1 comm_hyp]
      ...  = (conj 1 g) * (conj a' g⁻¹) * (conj (b*a') g) * (conj b g⁻¹) : by simp [a', conj],

  existsi [(1: α), a', (b*a'), b],
  assumption,
end

structure is_invariant_norm (ν : α → ℕ) : Prop :=
  (nonneg : ∀ g : α, 0 ≤ ν g) -- this is silly but ultimately the target will be ℝ
  (eq_zero : ∀ g : α, ν g = 0 → g = 1)
  (mul : ∀ g h : α, ν (g*h) ≤ ν g + ν h)
  (inv : ∀ g : α, ν g⁻¹ = ν g)
  (conj : ∀ g h : α, ν (h*g*h⁻¹) = ν g)
     
structure is_invariant_set (S : set α) : Prop :=
  (conj : ∀ g s : α, s ∈ S → conj g s ∈ S)
  (inv : ∀ s : α, s ∈ S → s⁻¹ ∈ S)
     
/- "is_in_ball S n a" means a belongs to the radius n ball around 1 for
   the norm associated to S on the subgroup generated by S. It can happen
   for three inductive reasons -/
inductive is_in_ball (S : set α) : ℕ → α → Prop
  | one (n): is_in_ball n 1
  | succ_plus (a ∈ S) {b n} : is_in_ball n b → is_in_ball (n+1) (a * b)
  | succ_minus (a ∈ S) {b n} : is_in_ball n b → is_in_ball (n+1) (a⁻¹ * b)


lemma is_in_ball_mono (S : set α) {m n} (h : m ≤ n) (a) : is_in_ball S m a → is_in_ball S n a :=
begin
intro ball_m,
induction ball_m,
case is_in_ball.one : 
{ constructor },
case is_in_ball.succ_plus : g g_in_S h p h_in_ball_h IH 
{ induction n with q IHq,
  { cases h_1 },
  { 
    
    
    admit } },
case is_in_ball.succ_minus : 
{ admit },
end

def is_generating (S) := ∀ a : α, ∃ n, is_in_ball S n a

/- the norm associated to a generating set S. Maybe not invariant if S isn't -/
def gen_norm {S : set α} (H : is_generating S) (a : α) := nat.find (H a)

lemma norm_is_in_ball {S : set α} (H : is_generating S) (a) :
is_in_ball S (gen_norm H a) a :=
nat.find_spec (H a)

lemma norm_min {S : set α} (H : is_generating S) {a n} :
is_in_ball S n a ↔ gen_norm H a ≤ n :=
⟨nat.find_min' (H a),
λ h, is_in_ball_mono S h _ (norm_is_in_ball H a)⟩

lemma is_in_ball_mul (S : set α) {m n a b}
  (h₁ : is_in_ball S m a) (h₂ : is_in_ball S n b) : is_in_ball S (m + n) (a * b) :=
begin
induction h₁,
case is_in_ball.one : p
{ simp,
  have ineq : n ≤ n + p, by simp[nat.zero_le],
  apply is_in_ball_mono S ineq,
  assumption },
case is_in_ball.succ_plus : g g_in_S h p h_in_ball_h IH
{ have numerology : p + 1 + n = (p + n) + 1, by simp,
  rw numerology, clear numerology,
  have groupology : g*h*b = g*(h*b), by simp,
  rw groupology, clear groupology,
  apply is_in_ball.succ_plus,
  repeat {assumption} },
case is_in_ball.succ_minus : g g_in_S h p h_in_ball_h IH  
{ have numerology : p + 1 + n = (p + n) + 1, by simp,
  rw numerology, clear numerology,
  have groupology : g⁻¹*h*b = g⁻¹*(h*b), by simp,
  rw groupology, clear groupology,
  apply is_in_ball.succ_minus,
  repeat {assumption} }
end

lemma is_in_ball_inv (S : set α) {n a} (h : is_in_ball S n a) : is_in_ball S n (a⁻¹) :=
begin
induction h,
case is_in_ball.one : p
{ simp, constructor },
case is_in_ball.succ_plus : g g_in_S h p h_in_ball_h IH
{ admit },
case is_in_ball.succ_minus : g g_in_S h p h_in_ball_h IH
{ admit },
end

lemma is_in_ball_conj {S T : set α} (g) (H : ∀ a, a ∈ S → conj g a ∈ T)
  {n a} (h : is_in_ball S n a) : is_in_ball T n (conj g a) :=
sorry


lemma inv_norm_of_inv_set {S : set α} (H : is_generating S) :
is_invariant_set S → is_invariant_norm (gen_norm H) :=
begin
intro inv_hyp,
constructor; intros,
{ apply nat.zero_le },
{ have : is_in_ball S 0 g, {apply (norm_min H).2, rw a},
cases this, refl },
{ apply (norm_min H).1,
  exact is_in_ball_mul S (norm_is_in_ball H g) (norm_is_in_ball H h) },
{ admit },
{ admit },
end